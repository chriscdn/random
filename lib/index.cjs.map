{"version":3,"sources":["../src/index.ts"],"sourcesContent":["const assert = (condition: boolean, message = \"Assertion failed\") => {\n  if (!condition) {\n    throw new Error(message);\n  }\n};\n\nconst assertRange = ({\n  value,\n  min,\n  max,\n  inclusiveMin = true,\n  inclusiveMax = true,\n  name = \"value\",\n}: {\n  value: number;\n  min: number;\n  max: number;\n  inclusiveMin?: boolean;\n  inclusiveMax?: boolean;\n  name?: string;\n}) => {\n  assert(min <= max, \"min must be less than or equal to max\");\n\n  const lowerOk = inclusiveMin ? value >= min : value > min;\n  const upperOk = inclusiveMax ? value <= max : value < max;\n\n  assert(\n    lowerOk && upperOk,\n    `${name} must be between ${inclusiveMin ? \"[\" : \"(\"}${min}, ${max}${\n      inclusiveMax ? \"]\" : \")\"\n    }`,\n  );\n};\n\nconst assertCryptoRandomValues = () => {\n  if (\n    typeof crypto === \"undefined\" ||\n    typeof crypto.getRandomValues !== \"function\"\n  ) {\n    throw new Error(\"High-entropy randomness requires crypto.getRandomValues\");\n  }\n};\n\nconst assertCryptoUUID = () => {\n  if (\n    typeof crypto === \"undefined\" || typeof crypto.randomUUID !== \"function\"\n  ) {\n    throw new Error(\"UUID generation requires crypto.randomUUID\");\n  }\n};\n\ntype NumericRangeOptions = {\n  min: number;\n  max: number;\n  highEntropy?: boolean;\n};\n\nconst _random01 = (\n  { highEntropy = false }: { highEntropy?: boolean } = {},\n) => {\n  if (highEntropy) {\n    assertCryptoRandomValues();\n    const arr = new Uint32Array(1);\n    crypto.getRandomValues(arr);\n    return arr[0]! / 0x100000000; // 2^32\n  } else {\n    return Math.random();\n  }\n};\n\n/**\n * Returns a random float between min (inclusive) and max (exclusive).\n *\n * @param {Object} options\n * @param {number} options.min - The lower bound (inclusive).\n * @param {number} options.max - The upper bound (exclusive).\n * @param {boolean} [options.highEntropy=false] - Use Web Crypto API.\n *\n * @returns {number}\n */\nconst randomFloat = (\n  { min, max, highEntropy = false }: NumericRangeOptions,\n) => {\n  assert(min <= max, \"min must be less than or equal to max\");\n  return _random01({ highEntropy }) * (max - min) + min;\n};\n\n/**\n * Returns a random integer between min (inclusive) and max (exclusive).\n *\n * @param {Object} options\n * @param {number} options.min - The lower bound (inclusive).\n * @param {number} options.max - The upper bound (exclusive).\n * @param {boolean} [options.highEntropy=false] - Use Web Crypto API.\n *\n * @returns {number}\n */\nconst randomInteger = (options: NumericRangeOptions) =>\n  Math.floor(randomFloat(options));\n\n/**\n * Returns a random integer between min (inclusive) and max (inclusive).\n * @param {Object} options\n * @param {number} options.min - The lower bound (inclusive).\n * @param {number} options.max - The upper bound (inclusive).\n * @param {boolean} [options.highEntropy=false] - Use Web Crypto API.\n *\n * @returns {number}\n */\nconst randomIntegerInclusive = (options: NumericRangeOptions) => {\n  assert(\n    options.max < Number.MAX_SAFE_INTEGER,\n    \"max must be less than Number.MAX_SAFE_INTEGER for inclusive range\",\n  );\n\n  return randomInteger({ ...options, max: options.max + 1 });\n};\n\n/**\n * Picks a random element from an array.\n *\n * @template T\n * @param {T[]} arr - The array to pick from. Must not be empty.\n * @param {Object} [options] - Optional settings.\n * @param {boolean} [options.highEntropy=false] - Use Web Crypto API for higher-entropy randomness.\n *\n * @returns {T} A randomly selected element from the array.\n * @throws {Error} If the array is empty.\n */\nconst pickOne = <T>(arr: T[], { highEntropy = false } = {}): T => {\n  assert(arr.length > 0, \"Cannot pick from an empty array\");\n  return arr[randomInteger({ min: 0, max: arr.length, highEntropy })]!;\n};\n\n/**\n * Returns a shuffled array using the Fisher-Yates algorithm.\n *\n * If `inPlace` is true, the original array is shuffled directly. Otherwise, a\n * new shuffled copy is returned, leaving the original array unchanged.\n *\n * @template T\n * @param {T[]} arr - The array to shuffle.\n * @param {Object} [options]\n * @param {boolean} [options.highEntropy=false] - Use Web Crypto API for\n * higher-entropy randomness.\n * @param {boolean} [options.inPlace=false] - If true, shuffle the original\n * array in place.\n *\n * @returns {T[]} A new array with the elements shuffled.\n */\nconst shuffle = <T>(\n  arr: T[],\n  { highEntropy = false, inPlace = false } = {},\n): T[] => {\n  const arrCopy = inPlace ? arr : arr.slice(); // create a copy\n  for (let i = arrCopy.length - 1; i > 0; i--) {\n    const j = randomIntegerInclusive({ min: 0, max: i, highEntropy });\n    [arrCopy[i] as T, arrCopy[j] as T] = [arrCopy[j] as T, arrCopy[i] as T];\n  }\n  return arrCopy;\n};\n\n/**\n * Returns a random boolean based on a likelihood.\n *\n * @param {Object} [options]\n * @param {number} [options.likelihood=0.5] - Probability between 0 and 1.\n *\n * @returns {boolean}\n */\nconst randomBoolean = (\n  { likelihood = 0.5, highEntropy = false }: {\n    likelihood?: number;\n    highEntropy?: boolean;\n  } = {},\n) => {\n  assertRange({ value: likelihood, min: 0, max: 1, name: \"likelihood\" });\n  return randomFloat({ min: 0, max: 1, highEntropy }) < likelihood;\n};\n\n/**\n * Returns a random aspect ratio between 1 and maxRatio, or its reciprocal.\n * Ensures symmetric probability between portrait (<1) and landscape (>1).\n *\n * @param {Object} options\n * @param {number} options.maxRatio - Maximum ratio value. Can be less than 1; the function normalizes it to be >= 1.\n * @param {number} [options.landscapeLikelihood=0.5] - Probability that the returned ratio is landscape (greater than 1).\n *   A value of 0.5 gives equal chance for portrait and landscape.\n * @param {boolean} [options.highEntropy=false] - Use the Web Crypto API for high-entropy randomness.\n *\n * @returns {number} A ratio between 1/maxRatio and maxRatio, symmetric around 1.\n */\nconst randomAspectRatio = ({\n  maxRatio,\n  landscapeLikelihood = 0.5,\n  highEntropy = false,\n}: {\n  maxRatio: number;\n  landscapeLikelihood?: number;\n  highEntropy?: boolean;\n}) => {\n  assert(maxRatio > 0, \"maxRatio must be greater than 0\");\n\n  // Normalize so the upper bound is always >= 1\n  const upper = maxRatio >= 1 ? maxRatio : 1 / maxRatio;\n\n  const value = randomFloat({ min: 1, max: upper, highEntropy });\n\n  return randomBoolean({ likelihood: landscapeLikelihood, highEntropy })\n    ? value\n    : 1 / value;\n};\n\n/**\n * Generates a random string of specified length.\n *\n * @param {Object} [options]\n * @param {number} [options.length=20] - Number of characters to generate.\n * @param {string} [options.chars] - Character set to use.\n * @param {boolean} [options.highEntropy=false] - Use Web Crypto API.\n *\n * @returns {string}\n */\nconst randomString = ({\n  length = 20,\n  chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\",\n  highEntropy = false,\n}: { length?: number; chars?: string; highEntropy?: boolean } = {}) => {\n  const charCount = chars.length;\n\n  assert(charCount > 0, \"Character set cannot be empty\");\n  assert(length > 0, \"length must be greater than zero\");\n\n  if (highEntropy) {\n    assertCryptoRandomValues();\n\n    const bytes = new Uint32Array(length);\n    crypto.getRandomValues(bytes);\n    return Array.from(bytes, (b) => chars[b % charCount]).join(\"\");\n  } else {\n    return Array.from(\n      { length },\n      () =>\n        chars[randomInteger({ min: 0, max: charCount, highEntropy: false })],\n    ).join(\"\");\n  }\n};\n\n/**\n * Generates a 22-character high-entropy unique identifier.\n *\n * The ID is:\n *\n * - Composed of URL-safe characters (A-Z, a-z, 0-9)\n * - Provides ~128 bits of entropy, making collisions extremely unlikely\n * - Comparable in uniqueness to a UUID v4\n * - Suitable for use in URLs, database keys, and other unique token scenarios\n *\n * For custom lengths, alphabets, or entropy settings, use {@link randomString}.\n *\n * @returns {string} A 22-character random string identifier\n */\nconst randomId = () => randomString({ length: 22, highEntropy: true });\n\n/**\n * Generates a cryptographically secure UUID (version 4).\n *\n * Uses the Web Crypto API `crypto.randomUUID()` implementation,\n * which produces an RFC 4122 compliant v4 UUID.\n *\n * Requires a runtime environment that supports the Web Crypto API.\n * Throws an error if `crypto.randomUUID` is unavailable.\n *\n * @returns {string} A v4 UUID string (e.g. \"550e8400-e29b-41d4-a716-446655440000\")\n * @throws {Error} If cryptographic randomness is not available.\n */\nconst randomUUID = () => {\n  assertCryptoUUID();\n  return crypto.randomUUID();\n};\n\nexport {\n  pickOne,\n  randomAspectRatio,\n  randomBoolean,\n  randomFloat,\n  randomId,\n  randomInteger,\n  randomIntegerInclusive,\n  randomString,\n  randomUUID,\n  shuffle,\n};\n"],"mappings":"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","names":[]}